\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{mathtools}
\usepackage{listings}
\usepackage{hyperref}
\geometry{margin=1in}

\begin{document}
\Large{\texttt{Name: Bhargey Mehta}}

\Large{\texttt{SID : \space 201701074}}

\Large{\texttt{Info: AGT - Project - Sequential Blossom}}

\section{Algorithm}
The algorithm described here is called "Blossom Algorithm" developed by Jack Edmonds. Before we describe the algorithm, we need to define certain terms which will be used in the algorithm to ease explanations.

\begin{itemize}
    \item Blossom: A cycle of odd length i.e. containing odd number of edges and odd number of nodes.
    \item Unsaturated vertex $v$ (wrt a matching $M$ of a graph $G$): The node $v$ belongs to the graph $G$ but not present in matching $M$.
\end{itemize}

Subroutine: findMaxMatching($G$, $M$) \dotfill

\hspace{1cm} $P \leftarrow$ findAugmentingPath($G$, $M$)

\hspace{1cm} if $P$ is empty

\hspace{2cm} return $M$

\hspace{1cm} $M^+ \leftarrow$ increased matching of $M$ by adding alternating edges of $P$

\hspace{1cm} return findMaxMatching($G$, $M^+$)

\vspace{0.5cm}

Subroutine: addToForest($M, F, v, w$, terminals, rootOfNode) \dotfill

\hspace{1cm} $x \leftarrow$ node adjacent to $w$ in $M$

\hspace{1cm} add edges $(v, w)$ and $(w, x)$ in $F$

\hspace{1cm} add node $x$ in terminals

\hspace{1cm} rootOfNode($w$) $\leftarrow$ rootOfNode($v$)

\hspace{1cm} rootOfNode($x$) $\leftarrow$ rootOfNode($v$)

\vspace{0.5cm}




Subroutine: findAugmentingPath($G$, $M$) \dotfill

\hspace{1cm} $F \leftarrow$ empty forest

\hspace{1cm} rootOfNode $\leftarrow$ empty node-to-node mapping

\hspace{1cm} terminals $\leftarrow$ unsaturated vertices of $G$

\hspace{1cm} for each node $v$ in terminals

\hspace{2cm} rootOfNode($v$) $\leftarrow v$

\hspace{1cm} mark all edges of $M$ in $G$

\hspace{1cm} for each node $v$ in terminals

\hspace{2cm} for each unmarked edge $(v, w)$ adjacent to $v$

\hspace{3cm} if $w \in M$

\hspace{4cm} addToForest($M$, $F$, $v$, $w$, terminals, rootOfNode)

\hspace{3cm} else 

\hspace{4cm} $p_w \leftarrow$ rootOfNode($w$)

\hspace{4cm} if $d(w, p_w)$ is even (including 0)

\hspace{5cm} $p_v \leftarrow$ rootOfNode($v$)

\hspace{5cm} if $p_v$ == $p_w$

\hspace{6cm} $P \leftarrow$ blossomRecursion($G, M, F, v, w$)

\hspace{5cm} else 

\hspace{6cm} $P \leftarrow$ constructPath($F, v, w$, rootOfNode)

\hspace{5cm} return $P$

\hspace{3cm} mark edge $(v, w)$

\hspace{1cm} return empty path

\vspace{0.5cm}

Subroutine: constructPath($F, v, w$, rootOfNode) \dotfill

\hspace{1cm} $p_v \leftarrow$ rootOfNode($v$)

\hspace{1cm} $p_w \leftarrow$ rootOfNode($w$)

\hspace{1cm} $P_1 \leftarrow$ Path from $v$ to $p_v$ in forest $F$

\hspace{1cm} $P_2 \leftarrow$ Path from $v$ to $p_w$ in forest $F$

\hspace{1cm} return $P_1 + P_2$

\vspace{0.5cm}

Subroutine: blossomRecursion($G, M, F, v, w$) \dotfill

\hspace{1cm} $B \leftarrow$ nodes in path from $v \to w$ in $F$

\hspace{1cm} $G^+ \leftarrow G$ with all nodes of $B$ contracted into $w$

\hspace{1cm} $M^+ \leftarrow M$ with all nodes of $B$ contracted into $w$

\hspace{1cm} $P^+ \leftarrow$ findAugmentingPath($G^+, M^+$)

\hspace{1cm} if $w \in P^+$

\hspace{2cm} $P \leftarrow$ liftBlossom($B, P^+, M$)

\hspace{2cm} return $P$

\hspace{1cm} return $P^+$

\vspace{0.5cm}

Subroutine: liftBlossom($B, P^+, M$) \dotfill

\hspace{1cm} $v \leftarrow$ node in $B$ such that it is incident on 2 edges not present in $M$

\hspace{1cm} $x \leftarrow$ node in $B$ such that $(x, x') \in P^+$ but $(x, x') \notin M$

\hspace{1cm} if no such $x$ exists, return empty path

\hspace{1cm} $P_1 \leftarrow$ subpath of $P^+$ ending at $v$

\hspace{1cm} $P_2 \leftarrow$ subpath of $P^+$ ending at $x$

\hspace{1cm} $P_B \leftarrow$ path which begins at $(x, y)$ such that $(x, y) \in M$ and ends at $v$

\hspace{1cm} $P \leftarrow P_1 + P_B + P_2$

\hspace{1cm} return $P$

\begin{figure}[!h]
    \centering
    \includegraphics[scale=0.75]{lifting.jpg}
    \caption{Lifting a Blossom}
\end{figure}


\section{Proof of Correctness}
\subsection{Lemmas}
\subsubsection{Augmenting Path Lemma}
Given a graph $G$, a matching $M$ is maximum if and only if there is no augmenting path in $G$.

This lemma has been proved in lecture so we use it as it is.

\subsubsection{Identification Lemma}
Identification Lemma: This algorithm identifies Blossoms correctly.

The Blossom Recursion subroutine is executed only when the following conditions hold. This is because the conditions we impose before executing the said subroutine.
\begin{enumerate}
    \item Edge $(v, w)$ is unmarked.
    \item The parent of $v$ and $w$ is same i.e. $p_v = p_w$. Hence both are reachable from each other.
    \item Node $w$ is at an even distance from it's root $p_v$.
\end{enumerate}
Now there are 2 cases.
\begin{itemize}
    \item Case A: $v \in M$. 
        In this case $v$ must have been added to the list of terminal nodes by some other node and due to the structure of addToForest subroutine, we always add nodes which are at even distance from some original root of forest $F$. 
    \item Case B: $v \notin M$ or equivalently $v \in F$.
        In this case $v$ itself is a root and it's distance is 0, hence even.
\end{itemize}
Hence both $v$ and $w$ are at an even distance from $p_v$ and so the path that exists between them in $F$ is of even length. This path together with the edge $(v, w)$ forms a blossom.

\subsubsection{Base Lemma}
Since this blossom is formed of edges alternating in $M$ and length of the cycle is odd, there is exactly one node in blossom which is incident on 2 edges which are both absent in $M$ but present in the blossom. We call this vertex as the base of the blossom.

Stem Lemma: If the base is saturated by $M$, then the augmenting path $P^+$ which passes through the contracted blossom, passes through it such that it passes through the base.

The above lemma is true since, if it is not the case then it would imply that the vertex (which is not a base) is incident on 2 edges which are present in $M$ which contradicts the definition of $M$.

Note that in the figure above, node $v$ is the base of the blossom of size 5.

\subsection{Blossom Lemma}
Blossom Lemma: $G$ contains an augmenting path if and only if $G^+$ (the graph after contraction of blossom) contains an augmenting path.

Note that if the augmenting path in $G$ or $G^+$ doesn't pass through the blossom, then the proof is trivial since the path in both of them is exactly equal.

\subsubsection{Forward Proof}
There are 2 cases depending upon whether or not the blossom is internal to the augmenting path in $G^+$ or is an endpoint.
\begin{itemize}
    \item Case A: Blossom is internal to the augmenting path. 
        
        Observation $A_1$: Due to the base lemma proved above, there is one node which is the base (defined in lemma above) and hence the edge which enters into the blossom is in the matching.
        
        Observation $A_2$: Any other node is in the matching $M$ such that it's corresponding edge belongs to the matching and hence the edge which exits the blossom to the other end is not in the matching.
        
        From the above 2 observations, when the blossom is contracted into a single node, these 2 edges are alternating edges and hence the corresponding path in $G^+$ is augmenting.
    \item Case B: Blossom is an endpoint.
        
        Observation $A_2$ holds for this case also.
        
        Now since, the blossom is internal, the blossom becomes an unsaturated vertex since there is no edge incoming to this contracted blossom. 
        
        Hence we can say that the augmenting path in $G^+$ is aagain an augmenting path.
        
\end{itemize}


\subsubsection{Backward Proof}
Now since the blossom is of odd length, (WLOG) if we consider the base as the entry point and the other vertex as the exit point in the blossom, we can see that there are 2 paths (one travelling the upper path and the other travelling the lower path) between them. 

Independent of the position of the exit point wrt the entry point (base vertex), there is always a path of even length and a path of odd length. 

If we traverse from the base on the even length portion of the blossom, the first edge is not in the matching and the subsequent edges alternate. And since the path is of even length, the last edge is necessarily in matching.

Now again there are 2 cases.
\begin{itemize}
    \item Case A: Blossom is internal.
        
        According to the base lemma, the subpath outside the blossom attaching the unsaturated vertex to the base will end with an edge (incident on base) which is in the matching.
        
        For the edge connecting the exit point with the other unsaturated vertex, it is necessarily not in matching since the corresponding edge in matching $M$ belongs to the blossom.
        
        Hence in this case, the paths described above in union with the even length path forms an augmenting path in $G$.
    \item Case B: Blossom is and endpoint.
    
        For this case the first path in case A is an empty path and rest of the reasoning remains the same.
        
        Hence in this case also, the union of these paths forms an augmenting path in $G$.
\end{itemize}
Hence from the above Blossom Lemma in combination with the augmenting path lemma and the identification lemma, we can say that our algorithm is correct.

\section{Complexity Analysis}
\begin{itemize}
    \item The addToForest subroutine takes O(1) time since all 6 steps complete in constant time.
    \item The constructPath subroutine takes O($N$) time since the maximum length of a path can be $N$.
    \item The liftBlossom subroutine takes O($N$) time since the maximum length of the path can be $N$ and the decision to decide the subportion of the blossom to include in lifting the path is done in constant time.
    \item The findMaxMatching function is called recursively at max $\frac{N}{2}$ times since the size of the matching increases by 2 in every recursion call. Hence the time complexity is O$(N*$ cost of findAugmentingPath subroutine)
    \item Each call to the blossomRecursion subroutine will take at max O($N$) time since in each call the cost is equal to the size of the blossom found. The sum of size of all blossom cannot be more than $N$ since after each call the nodes are contracted and hence over counting cannot happen. Hence the top-level call will take O($N$) time.
    \item The number of iterations of loop over the edges in findAugmenting path is bound by $M$. See that addToForest subroutine takes O(1) time, constructPath subroutine takes O($N$) time and the blossomRecursion subroutine takes O$(N)$ time. Hence each iteration takes O$(1+N+N)$ = O($N$) time. Hence the time complexity is O$(M*N)$.
\end{itemize}

Finally plug the above result in time complexity of findMaxMatching function. Hence overall time complexity of the entire algorithm is O$(N * O(M*N)) = $ O($N^2M$).

\section{References}
\begin{itemize}
    \item \href{https://stanford.edu/~rezab/classes/cme323/S16/projects_reports/shoemaker_vare.pdf}{\color{blue} Blossom Algorithm Analysis by Amy Shoemaker \& Sagar Vare (Clickable URL)}
    \item \href{https://en.wikipedia.org/wiki/Blossom_algorithm}{\color{blue} Wikipedia Blossom Algorithm (Clickable URL)}
\end{itemize}



\end{document}
